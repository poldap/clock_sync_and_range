# Clock synchronization over networks — Identifiability of the sawtooth model

This GitHub repository contains the code and explanations that complement the paper "Clock synchronization over networks — Identifiability of the sawtooth model".
### Pol del Aguila Pla [[1]](https://poldap.github.io/#/), Lissy Pellaco [[2]](https://www.kth.se/profile/pellaco), Satyam Dwivedi [[3]](https://www.researchgate.net/profile/Satyam_Dwivedi2), Peter Händel [[4]](https://www.kth.se/profile/ph/) and Joakim Jaldén [[5]](https://www.kth.se/profile/jalden/)

[[1]](https://poldap.github.io/#/): Pol del Aguila Pla's research website<br/>
[[2]](https://www.kth.se/profile/pellaco): Lissy Pellaco's research profile at KTH<br/>
[[3]](https://www.kth.se/profile/pellaco): Satyam Dwivedi's researchgate profile<br/>
[[4]](https://www.kth.se/profile/ph/): Peter Händel's research profile at KTH<br/>
[[5]](https://www.kth.se/profile/jalden/): Joakim Jaldén's research profile at KTH<br/>

## Computation Environment
In order to run our code successfully and in a moderate time, you will need access to a powerful computer, preferably equipped with a GPU. For reference, all our experiments have been run on a computer equipped with an NVIDIA Tesla P100 GPU, an Intel Xeon E5-1650 v3 CPU, and 62 GB of RAM. In case you do not have access to a GPU, we recommend skipping the intensive-to-compute plots and we suggest to directly load the plots that can be found in the repository (check). 
Doing this will verify the results for the training dataset generated by you and using the pre-trained models from our simulations for the paper. 
You can also investigate how the estimation strategies work and can be implemented exploring the code in. (Note that the code uses a fixed seed value that you can modify to generate randomized training images.)

## Explaining code 
The simplest way to read through the annotated code is to open the relevant *.ipynb 'notebook' files through [nbviewer.jupyter.org](https://nbviewer.jupyter.org/github/poldap/SpotNet/tree/master/) You can use [nbviewer.jupyter.org](https://nbviewer.jupyter.org/github/poldap/SpotNet/tree/master/) from any modern browser, without any further installation requirements. Note that this option only allows you to visualize the notebooks, and it is not possible to execute the code or reproduce the results from the paper in this manner.

## Executing the code
If you would like to execute the code on your own computation environment and fully replicate our results, the software requirements are:

    Python 3 (for reference, we used python 3.6.5), along with the scientific computing packages numpy, scipy, scikit-image, and matplotlib.
    Jupyter (for reference, we used jupyter 4.4.0), and
    TensorFlow (for reference, we used tensorflow 1.8.0 compiled for use in the GPU with cudnn 7.1 and nccl 2.1.15).

To execute our code, you will need to be familiar with Jupyter notebooks running Python code. For that, you can refer to any of the several freely available tutorials, like [this one](https://codingthesmartway.com/getting-started-with-jupyter-notebook-for-python/). After installation of the required packages, navigate to the folder where this repository has been cloned and execute jupyter notebook to launch the Jupyter notebook server ihttps://codingthesmartway.com/getting-started-with-jupyter-notebook-for-python/n that folder. Then, a simple click to any of the *.ipynb files listed in the Jupyter notebook website loads it on a new tab, where controls for running our code are available. 

In the following, we go through the different notebooks included.

### Imports and library of basic functions.ipynb
In this notebook we provide the basic imports and self-defined functions needed for the implementation of the different concepts and results considered in our paper [[1]](#references).

### Estimation strategies.ipynb
In this notebook we implement our reference estimation strategies: (see Section IV.B of our paper [1]) and showcase them by simple examples.

### Cramér-Rao lower bounds and Monte Carlo experiments.ipynb
In this we implement 1) the computation of the CRLBs for an unwrapped model (see Section IV.A of our paper [1]), and 2) the basic machinery to run Monte Carlo experiments with our proposed estimation approaches (see Section IV.B of our paper [[1]](#references) and [estimation_strategies.ipynb](#estimation-strategies.ipynb) for their implementation) with respect to the different parameters of interest in the clock synchronization and ranging problem. 

## Simulated nodes.ipynb
## Real parameters for simluated nodes.ipynb

## References
[[1]](#ourpaper): Pol del Aguila Pla, Lissy Pellaco, Satyam Dwivedi, Peter Händel and Joakim Jaldén, "Clock synchronization over networks — Identifiability of the sawtooth model", Preprint, submitted to IEEE Transactions on Automatic Control, 2019.
